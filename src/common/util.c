/* util.c generated by valac 0.28.0, the Vala compiler
 * generated from util.vala, do not modify */

/*
 * Seahorse
 *
 * Copyright (C) 2003 Jacob Perkins
 * Copyright (C) 2004-2005 Stefan Walter
 * Copyright (C) 2011 Collabora Ltd.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include "seahorse-common.h"
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <glib/gi18n-lib.h>

#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))





static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void seahorse_util_show_error (GtkWidget* parent, const gchar* heading, const gchar* message) {
	GtkWindow* window = NULL;
	const gchar* _tmp0_ = NULL;
	GtkWidget* _tmp1_ = NULL;
	GtkMessageDialog* dialog = NULL;
	GtkWindow* _tmp8_ = NULL;
	GtkMessageDialog* _tmp9_ = NULL;
	const gchar* _tmp10_ = NULL;
	GtkMessageDialog* _tmp16_ = NULL;
	GtkMessageDialog* _tmp17_ = NULL;
	window = NULL;
	_tmp0_ = message;
	if (_tmp0_ == NULL) {
		message = "";
	}
	_tmp1_ = parent;
	if (_tmp1_ != NULL) {
		GtkWidget* _tmp2_ = NULL;
		GtkWidget* _tmp5_ = NULL;
		_tmp2_ = parent;
		if (!G_TYPE_CHECK_INSTANCE_TYPE (_tmp2_, gtk_window_get_type ())) {
			GtkWidget* _tmp3_ = NULL;
			GtkWidget* _tmp4_ = NULL;
			_tmp3_ = parent;
			_tmp4_ = gtk_widget_get_toplevel (_tmp3_);
			parent = _tmp4_;
		}
		_tmp5_ = parent;
		if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp5_, gtk_window_get_type ())) {
			GtkWidget* _tmp6_ = NULL;
			GtkWindow* _tmp7_ = NULL;
			_tmp6_ = parent;
			_tmp7_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp6_, gtk_window_get_type (), GtkWindow));
			_g_object_unref0 (window);
			window = _tmp7_;
		}
	}
	_tmp8_ = window;
	_tmp9_ = (GtkMessageDialog*) gtk_message_dialog_new (_tmp8_, GTK_DIALOG_MODAL, GTK_MESSAGE_ERROR, GTK_BUTTONS_CLOSE, "");
	g_object_ref_sink (_tmp9_);
	dialog = _tmp9_;
	_tmp10_ = heading;
	if (_tmp10_ == NULL) {
		GtkMessageDialog* _tmp11_ = NULL;
		const gchar* _tmp12_ = NULL;
		_tmp11_ = dialog;
		_tmp12_ = message;
		g_object_set ((GObject*) _tmp11_, "text", _tmp12_, NULL);
	} else {
		GtkMessageDialog* _tmp13_ = NULL;
		const gchar* _tmp14_ = NULL;
		const gchar* _tmp15_ = NULL;
		_tmp13_ = dialog;
		_tmp14_ = heading;
		_tmp15_ = message;
		g_object_set ((GObject*) _tmp13_, "text", _tmp14_, "secondary-text", _tmp15_, NULL);
	}
	_tmp16_ = dialog;
	gtk_dialog_run ((GtkDialog*) _tmp16_);
	_tmp17_ = dialog;
	gtk_widget_destroy ((GtkWidget*) _tmp17_);
	_g_object_unref0 (dialog);
	_g_object_unref0 (window);
}


gchar* seahorse_util_get_display_date_string (glong time) {
	gchar* result = NULL;
	glong _tmp0_ = 0L;
	GDate created_date = {0};
	glong _tmp2_ = 0L;
	gchar* buffer = NULL;
	gchar* _tmp3_ = NULL;
	gint buffer_length1 = 0;
	gint _buffer_size_ = 0;
	gchar* _tmp4_ = NULL;
	gint _tmp4__length1 = 0;
	const gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	gint _tmp6__length1 = 0;
	gchar* _tmp7_ = NULL;
	_tmp0_ = time;
	if (_tmp0_ == ((glong) 0)) {
		gchar* _tmp1_ = NULL;
		_tmp1_ = g_strdup ("");
		result = _tmp1_;
		return result;
	}
	memset (&created_date, 0, sizeof (GDate));
	_tmp2_ = time;
	g_date_set_time_t (&created_date, (time_t) _tmp2_);
	_tmp3_ = g_new0 (gchar, 128);
	buffer = _tmp3_;
	buffer_length1 = 128;
	_buffer_size_ = buffer_length1;
	_tmp4_ = buffer;
	_tmp4__length1 = buffer_length1;
	_tmp5_ = _ ("%Y-%m-%d");
	g_date_strftime (_tmp4_, _tmp4__length1, _tmp5_, &created_date);
	_tmp6_ = buffer;
	_tmp6__length1 = buffer_length1;
	_tmp7_ = g_strdup ((const gchar*) _tmp6_);
	result = _tmp7_;
	buffer = (g_free (buffer), NULL);
	return result;
}


GtkBuilder* seahorse_util_load_built_contents (GtkContainer* frame, const gchar* name) {
	GtkBuilder* result = NULL;
	GtkBuilder* builder = NULL;
	GtkBuilder* _tmp0_ = NULL;
	gchar* path = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	GtkContainer* _tmp4_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (name != NULL, NULL);
	_tmp0_ = gtk_builder_new ();
	builder = _tmp0_;
	_tmp1_ = name;
	_tmp2_ = g_strdup_printf ("/org/gnome/Seahorse/seahorse-%s.xml", _tmp1_);
	path = _tmp2_;
	_tmp4_ = frame;
	if (_tmp4_ != NULL) {
		GtkContainer* _tmp5_ = NULL;
		_tmp5_ = frame;
		_tmp3_ = G_TYPE_CHECK_INSTANCE_TYPE (_tmp5_, gtk_dialog_get_type ());
	} else {
		_tmp3_ = FALSE;
	}
	if (_tmp3_) {
		GtkContainer* _tmp6_ = NULL;
		GtkBox* _tmp7_ = NULL;
		_tmp6_ = frame;
		_tmp7_ = (GtkBox*) gtk_dialog_get_content_area (G_TYPE_CHECK_INSTANCE_CAST (_tmp6_, gtk_dialog_get_type (), GtkDialog));
		frame = (GtkContainer*) _tmp7_;
	}
	{
		GtkBuilder* _tmp8_ = NULL;
		const gchar* _tmp9_ = NULL;
		GObject* obj = NULL;
		GtkBuilder* _tmp10_ = NULL;
		const gchar* _tmp11_ = NULL;
		GObject* _tmp12_ = NULL;
		GObject* _tmp13_ = NULL;
		GObject* _tmp14_ = NULL;
		_tmp8_ = builder;
		_tmp9_ = path;
		gtk_builder_add_from_resource (_tmp8_, _tmp9_, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch7_g_error;
		}
		_tmp10_ = builder;
		_tmp11_ = name;
		_tmp12_ = gtk_builder_get_object (_tmp10_, _tmp11_);
		_tmp13_ = _g_object_ref0 (_tmp12_);
		obj = _tmp13_;
		_tmp14_ = obj;
		if (_tmp14_ == NULL) {
			const gchar* _tmp15_ = NULL;
			const gchar* _tmp16_ = NULL;
			_tmp15_ = name;
			_tmp16_ = path;
			g_critical ("util.vala:75: Couldn't find object named %s in %s", _tmp15_, _tmp16_);
		} else {
			GtkContainer* _tmp17_ = NULL;
			_tmp17_ = frame;
			if (_tmp17_ != NULL) {
				GtkWidget* widget = NULL;
				GObject* _tmp18_ = NULL;
				GtkWidget* _tmp19_ = NULL;
				GtkContainer* _tmp20_ = NULL;
				GtkWidget* _tmp21_ = NULL;
				GtkWidget* _tmp22_ = NULL;
				_tmp18_ = obj;
				_tmp19_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp18_, gtk_widget_get_type (), GtkWidget));
				widget = _tmp19_;
				_tmp20_ = frame;
				_tmp21_ = widget;
				gtk_container_add (_tmp20_, _tmp21_);
				_tmp22_ = widget;
				gtk_widget_show (_tmp22_);
				_g_object_unref0 (widget);
			}
		}
		_g_object_unref0 (obj);
	}
	goto __finally7;
	__catch7_g_error:
	{
		GError* err = NULL;
		const gchar* _tmp23_ = NULL;
		GError* _tmp24_ = NULL;
		const gchar* _tmp25_ = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp23_ = path;
		_tmp24_ = err;
		_tmp25_ = _tmp24_->message;
		g_critical ("util.vala:82: Couldn't load %s: %s", _tmp23_, _tmp25_);
		_g_error_free0 (err);
	}
	__finally7:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_free0 (path);
		_g_object_unref0 (builder);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = builder;
	_g_free0 (path);
	return result;
}



