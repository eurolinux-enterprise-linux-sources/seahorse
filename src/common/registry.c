/* registry.c generated by valac 0.28.0, the Vala compiler
 * generated from registry.vala, do not modify */

/*
 * Seahorse
 *
 * Copyright (C) 2008 Stefan Walter
 * Copyright (C) 2013 Stefan Walter
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include "seahorse-common.h"
#include <stdlib.h>
#include <string.h>

#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define __g_list_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_object_unref0_ (var), NULL)))

struct _SeahorseRegistryPrivate {
	GHashTable* _objects;
};


static gpointer seahorse_registry_parent_class = NULL;
static SeahorseRegistry* seahorse_registry__singleton;
static SeahorseRegistry* seahorse_registry__singleton = NULL;

#define SEAHORSE_REGISTRY_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SEAHORSE_TYPE_REGISTRY, SeahorseRegistryPrivate))
enum  {
	SEAHORSE_REGISTRY_DUMMY_PROPERTY
};
static SeahorseRegistry* seahorse_registry_instance (void);
static void _g_object_unref0_ (gpointer var);
static void _g_list_free__g_object_unref0_ (GList* self);
static GObject * seahorse_registry_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void _g_hash_table_unref0_ (gpointer var);
static void seahorse_registry_finalize (GObject* obj);


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static SeahorseRegistry* seahorse_registry_instance (void) {
	SeahorseRegistry* result = NULL;
	SeahorseRegistry* _tmp0_ = NULL;
	SeahorseRegistry* _tmp2_ = NULL;
	SeahorseRegistry* _tmp3_ = NULL;
	_tmp0_ = seahorse_registry__singleton;
	if (_tmp0_ == NULL) {
		SeahorseRegistry* _tmp1_ = NULL;
		_tmp1_ = seahorse_registry_new ();
		_g_object_unref0 (seahorse_registry__singleton);
		seahorse_registry__singleton = _tmp1_;
	}
	_tmp2_ = seahorse_registry__singleton;
	_tmp3_ = _g_object_ref0 (_tmp2_);
	result = _tmp3_;
	return result;
}


void seahorse_registry_cleanup (void) {
	_g_object_unref0 (seahorse_registry__singleton);
	seahorse_registry__singleton = NULL;
}


static gpointer _g_hash_table_ref0 (gpointer self) {
	return self ? g_hash_table_ref (self) : NULL;
}


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


void seahorse_registry_register_object (GObject* object, const gchar* category) {
	SeahorseRegistry* registry = NULL;
	SeahorseRegistry* _tmp0_ = NULL;
	GHashTable* oset = NULL;
	SeahorseRegistry* _tmp1_ = NULL;
	GHashTable* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gconstpointer _tmp4_ = NULL;
	GHashTable* _tmp5_ = NULL;
	GHashTable* _tmp6_ = NULL;
	GHashTable* _tmp16_ = NULL;
	GObject* _tmp17_ = NULL;
	GObject* _tmp18_ = NULL;
	GObject* _tmp19_ = NULL;
	GObject* _tmp20_ = NULL;
	g_return_if_fail (object != NULL);
	g_return_if_fail (category != NULL);
	_tmp0_ = seahorse_registry_instance ();
	registry = _tmp0_;
	_tmp1_ = registry;
	_tmp2_ = _tmp1_->priv->_objects;
	_tmp3_ = category;
	_tmp4_ = g_hash_table_lookup (_tmp2_, _tmp3_);
	_tmp5_ = _g_hash_table_ref0 ((GHashTable*) _tmp4_);
	_g_hash_table_unref0 (oset);
	oset = _tmp5_;
	_tmp6_ = oset;
	if (_tmp6_ == NULL) {
		GHashFunc _tmp7_ = NULL;
		GEqualFunc _tmp8_ = NULL;
		GHashTable* _tmp9_ = NULL;
		SeahorseRegistry* _tmp10_ = NULL;
		GHashTable* _tmp11_ = NULL;
		const gchar* _tmp12_ = NULL;
		gchar* _tmp13_ = NULL;
		GHashTable* _tmp14_ = NULL;
		GHashTable* _tmp15_ = NULL;
		_tmp7_ = g_direct_hash;
		_tmp8_ = g_direct_equal;
		_tmp9_ = g_hash_table_new_full (_tmp7_, _tmp8_, _g_object_unref0_, _g_object_unref0_);
		_g_hash_table_unref0 (oset);
		oset = _tmp9_;
		_tmp10_ = registry;
		_tmp11_ = _tmp10_->priv->_objects;
		_tmp12_ = category;
		_tmp13_ = g_strdup (_tmp12_);
		_tmp14_ = oset;
		_tmp15_ = _g_hash_table_ref0 (_tmp14_);
		g_hash_table_replace (_tmp11_, _tmp13_, _tmp15_);
	}
	_tmp16_ = oset;
	_tmp17_ = object;
	_tmp18_ = _g_object_ref0 (_tmp17_);
	_tmp19_ = object;
	_tmp20_ = _g_object_ref0 (_tmp19_);
	g_hash_table_replace (_tmp16_, _tmp18_, _tmp20_);
	_g_hash_table_unref0 (oset);
	_g_object_unref0 (registry);
}


GObject* seahorse_registry_object_instance (const gchar* category) {
	GObject* result = NULL;
	SeahorseRegistry* registry = NULL;
	SeahorseRegistry* _tmp0_ = NULL;
	GHashTable* oset = NULL;
	SeahorseRegistry* _tmp1_ = NULL;
	GHashTable* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gconstpointer _tmp4_ = NULL;
	GHashTable* _tmp5_ = NULL;
	GHashTable* _tmp6_ = NULL;
	GHashTableIter iter = {0};
	GHashTable* _tmp7_ = NULL;
	GObject* key = NULL;
	GObject* value = NULL;
	g_return_val_if_fail (category != NULL, NULL);
	_tmp0_ = seahorse_registry_instance ();
	registry = _tmp0_;
	_tmp1_ = registry;
	_tmp2_ = _tmp1_->priv->_objects;
	_tmp3_ = category;
	_tmp4_ = g_hash_table_lookup (_tmp2_, _tmp3_);
	_tmp5_ = _g_hash_table_ref0 ((GHashTable*) _tmp4_);
	_g_hash_table_unref0 (oset);
	oset = _tmp5_;
	_tmp6_ = oset;
	if (_tmp6_ == NULL) {
		result = NULL;
		_g_hash_table_unref0 (oset);
		_g_object_unref0 (registry);
		return result;
	}
	_tmp7_ = oset;
	g_hash_table_iter_init (&iter, _tmp7_);
	while (TRUE) {
		gconstpointer _tmp8_ = NULL;
		gconstpointer _tmp9_ = NULL;
		gboolean _tmp10_ = FALSE;
		GObject* _tmp11_ = NULL;
		GObject* _tmp12_ = NULL;
		_tmp10_ = g_hash_table_iter_next (&iter, (gpointer*) (&_tmp8_), (gpointer*) (&_tmp9_));
		key = _tmp8_;
		value = _tmp9_;
		if (!_tmp10_) {
			break;
		}
		_tmp11_ = value;
		_tmp12_ = _g_object_ref0 (_tmp11_);
		result = _tmp12_;
		_g_hash_table_unref0 (oset);
		_g_object_unref0 (registry);
		return result;
	}
	result = NULL;
	_g_hash_table_unref0 (oset);
	_g_object_unref0 (registry);
	return result;
}


static void _g_list_free__g_object_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_object_unref0_, NULL);
	g_list_free (self);
}


GList* seahorse_registry_object_instances (const gchar* category) {
	GList* result = NULL;
	SeahorseRegistry* registry = NULL;
	SeahorseRegistry* _tmp0_ = NULL;
	GHashTable* oset = NULL;
	GList* insts = NULL;
	SeahorseRegistry* _tmp1_ = NULL;
	GHashTable* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gconstpointer _tmp4_ = NULL;
	GHashTable* _tmp5_ = NULL;
	GHashTable* _tmp6_ = NULL;
	GHashTableIter iter = {0};
	GHashTable* _tmp7_ = NULL;
	GObject* key = NULL;
	GObject* value = NULL;
	g_return_val_if_fail (category != NULL, NULL);
	_tmp0_ = seahorse_registry_instance ();
	registry = _tmp0_;
	insts = NULL;
	_tmp1_ = registry;
	_tmp2_ = _tmp1_->priv->_objects;
	_tmp3_ = category;
	_tmp4_ = g_hash_table_lookup (_tmp2_, _tmp3_);
	_tmp5_ = _g_hash_table_ref0 ((GHashTable*) _tmp4_);
	_g_hash_table_unref0 (oset);
	oset = _tmp5_;
	_tmp6_ = oset;
	if (_tmp6_ == NULL) {
		result = insts;
		_g_hash_table_unref0 (oset);
		_g_object_unref0 (registry);
		return result;
	}
	_tmp7_ = oset;
	g_hash_table_iter_init (&iter, _tmp7_);
	while (TRUE) {
		gconstpointer _tmp8_ = NULL;
		gconstpointer _tmp9_ = NULL;
		gboolean _tmp10_ = FALSE;
		GObject* _tmp11_ = NULL;
		GObject* _tmp12_ = NULL;
		_tmp10_ = g_hash_table_iter_next (&iter, (gpointer*) (&_tmp8_), (gpointer*) (&_tmp9_));
		key = _tmp8_;
		value = _tmp9_;
		if (!_tmp10_) {
			break;
		}
		_tmp11_ = value;
		_tmp12_ = _g_object_ref0 (_tmp11_);
		insts = g_list_append (insts, _tmp12_);
	}
	result = insts;
	_g_hash_table_unref0 (oset);
	_g_object_unref0 (registry);
	return result;
}


SeahorseRegistry* seahorse_registry_construct (GType object_type) {
	SeahorseRegistry * self = NULL;
	self = (SeahorseRegistry*) g_object_new (object_type, NULL);
	return self;
}


SeahorseRegistry* seahorse_registry_new (void) {
	return seahorse_registry_construct (SEAHORSE_TYPE_REGISTRY);
}


static void _g_hash_table_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL));
}


static GObject * seahorse_registry_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	SeahorseRegistry * self;
	GHashFunc _tmp0_ = NULL;
	GEqualFunc _tmp1_ = NULL;
	GHashTable* _tmp2_ = NULL;
	parent_class = G_OBJECT_CLASS (seahorse_registry_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SEAHORSE_TYPE_REGISTRY, SeahorseRegistry);
	_tmp0_ = g_str_hash;
	_tmp1_ = g_str_equal;
	_tmp2_ = g_hash_table_new_full (_tmp0_, _tmp1_, NULL, _g_hash_table_unref0_);
	_g_hash_table_unref0 (self->priv->_objects);
	self->priv->_objects = _tmp2_;
	return obj;
}


static void seahorse_registry_class_init (SeahorseRegistryClass * klass) {
	seahorse_registry_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SeahorseRegistryPrivate));
	G_OBJECT_CLASS (klass)->constructor = seahorse_registry_constructor;
	G_OBJECT_CLASS (klass)->finalize = seahorse_registry_finalize;
}


static void seahorse_registry_instance_init (SeahorseRegistry * self) {
	self->priv = SEAHORSE_REGISTRY_GET_PRIVATE (self);
}


static void seahorse_registry_finalize (GObject* obj) {
	SeahorseRegistry * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SEAHORSE_TYPE_REGISTRY, SeahorseRegistry);
	_g_hash_table_unref0 (self->priv->_objects);
	G_OBJECT_CLASS (seahorse_registry_parent_class)->finalize (obj);
}


GType seahorse_registry_get_type (void) {
	static volatile gsize seahorse_registry_type_id__volatile = 0;
	if (g_once_init_enter (&seahorse_registry_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SeahorseRegistryClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) seahorse_registry_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SeahorseRegistry), 0, (GInstanceInitFunc) seahorse_registry_instance_init, NULL };
		GType seahorse_registry_type_id;
		seahorse_registry_type_id = g_type_register_static (G_TYPE_OBJECT, "SeahorseRegistry", &g_define_type_info, 0);
		g_once_init_leave (&seahorse_registry_type_id__volatile, seahorse_registry_type_id);
	}
	return seahorse_registry_type_id__volatile;
}



