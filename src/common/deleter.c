/* deleter.c generated by valac 0.28.0, the Vala compiler
 * generated from deleter.vala, do not modify */

/*
 * Seahorse
 *
 * Copyright (C) 2011 Collabora Ltd.
 * Copyright (C) 2012 Stefan Walter
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Stef Walter <stefw@collabora.co.uk>
 */

#include <glib.h>
#include <glib-object.h>
#include "seahorse-common.h"
#include <gtk/gtk.h>
#include <gio/gio.h>

#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))


static gpointer seahorse_deleter_parent_class = NULL;

enum  {
	SEAHORSE_DELETER_DUMMY_PROPERTY
};
static GtkDialog* seahorse_deleter_real_create_confirm (SeahorseDeleter* self, GtkWindow* parent);
static GList* seahorse_deleter_real_get_objects (SeahorseDeleter* self);
static gboolean seahorse_deleter_real_add_object (SeahorseDeleter* self, GObject* obj);


static GtkDialog* seahorse_deleter_real_create_confirm (SeahorseDeleter* self, GtkWindow* parent) {
	g_critical ("Type `%s' does not implement abstract method `seahorse_deleter_create_confirm'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}


GtkDialog* seahorse_deleter_create_confirm (SeahorseDeleter* self, GtkWindow* parent) {
	g_return_val_if_fail (self != NULL, NULL);
	return SEAHORSE_DELETER_GET_CLASS (self)->create_confirm (self, parent);
}


static GList* seahorse_deleter_real_get_objects (SeahorseDeleter* self) {
	g_critical ("Type `%s' does not implement abstract method `seahorse_deleter_get_objects'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}


GList* seahorse_deleter_get_objects (SeahorseDeleter* self) {
	g_return_val_if_fail (self != NULL, NULL);
	return SEAHORSE_DELETER_GET_CLASS (self)->get_objects (self);
}


static gboolean seahorse_deleter_real_add_object (SeahorseDeleter* self, GObject* obj) {
	g_critical ("Type `%s' does not implement abstract method `seahorse_deleter_add_object'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return FALSE;
}


gboolean seahorse_deleter_add_object (SeahorseDeleter* self, GObject* obj) {
	g_return_val_if_fail (self != NULL, FALSE);
	return SEAHORSE_DELETER_GET_CLASS (self)->add_object (self, obj);
}


void seahorse_deleter_delete (SeahorseDeleter* self, GCancellable* cancellable, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	SEAHORSE_DELETER_GET_CLASS (self)->delete (self, cancellable, _callback_, _user_data_);
}


gboolean seahorse_deleter_delete_finish (SeahorseDeleter* self, GAsyncResult* _res_, GError** error) {
	return SEAHORSE_DELETER_GET_CLASS (self)->delete_finish (self, _res_, error);
}


gboolean seahorse_deleter_prompt (SeahorseDeleter* self, GtkWindow* parent) {
	gboolean result = FALSE;
	GtkDialog* prompt = NULL;
	GtkWindow* _tmp0_ = NULL;
	GtkDialog* _tmp1_ = NULL;
	gint res = 0;
	GtkDialog* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	GtkDialog* _tmp4_ = NULL;
	gboolean _tmp5_ = FALSE;
	gint _tmp6_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = parent;
	_tmp1_ = seahorse_deleter_create_confirm (self, _tmp0_);
	prompt = _tmp1_;
	_tmp2_ = prompt;
	_tmp3_ = gtk_dialog_run (_tmp2_);
	res = _tmp3_;
	_tmp4_ = prompt;
	gtk_widget_destroy ((GtkWidget*) _tmp4_);
	_tmp6_ = res;
	if (_tmp6_ == ((gint) GTK_RESPONSE_OK)) {
		_tmp5_ = TRUE;
	} else {
		gint _tmp7_ = 0;
		_tmp7_ = res;
		_tmp5_ = _tmp7_ == ((gint) GTK_RESPONSE_ACCEPT);
	}
	result = _tmp5_;
	_g_object_unref0 (prompt);
	return result;
}


SeahorseDeleter* seahorse_deleter_construct (GType object_type) {
	SeahorseDeleter * self = NULL;
	self = (SeahorseDeleter*) g_object_new (object_type, NULL);
	return self;
}


static void seahorse_deleter_class_init (SeahorseDeleterClass * klass) {
	seahorse_deleter_parent_class = g_type_class_peek_parent (klass);
	((SeahorseDeleterClass *) klass)->create_confirm = seahorse_deleter_real_create_confirm;
	((SeahorseDeleterClass *) klass)->get_objects = seahorse_deleter_real_get_objects;
	((SeahorseDeleterClass *) klass)->add_object = seahorse_deleter_real_add_object;
}


static void seahorse_deleter_instance_init (SeahorseDeleter * self) {
}


GType seahorse_deleter_get_type (void) {
	static volatile gsize seahorse_deleter_type_id__volatile = 0;
	if (g_once_init_enter (&seahorse_deleter_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SeahorseDeleterClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) seahorse_deleter_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SeahorseDeleter), 0, (GInstanceInitFunc) seahorse_deleter_instance_init, NULL };
		GType seahorse_deleter_type_id;
		seahorse_deleter_type_id = g_type_register_static (G_TYPE_OBJECT, "SeahorseDeleter", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&seahorse_deleter_type_id__volatile, seahorse_deleter_type_id);
	}
	return seahorse_deleter_type_id__volatile;
}



